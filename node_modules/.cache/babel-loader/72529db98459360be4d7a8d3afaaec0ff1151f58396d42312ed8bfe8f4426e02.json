{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar utils = require('../utils');\nvar NativeQuery = module.exports = function (config, values, callback) {\n  EventEmitter.call(this);\n  config = utils.normalizeQueryConfig(config, values, callback);\n  this.text = config.text;\n  this.values = config.values;\n  this.name = config.name;\n  this.callback = config.callback;\n  this.state = 'new';\n  this._arrayMode = config.rowMode === 'array';\n\n  // if the 'row' event is listened for\n  // then emit them as they come in\n  // without setting singleRowMode to true\n  // this has almost no meaning because libpq\n  // reads all rows into memory befor returning any\n  this._emitRowEvents = false;\n  this.on('newListener', function (event) {\n    if (event === 'row') this._emitRowEvents = true;\n  }.bind(this));\n};\nutil.inherits(NativeQuery, EventEmitter);\nvar errorFieldMap = {\n  /* eslint-disable quote-props */\n  sqlState: 'code',\n  statementPosition: 'position',\n  messagePrimary: 'message',\n  context: 'where',\n  schemaName: 'schema',\n  tableName: 'table',\n  columnName: 'column',\n  dataTypeName: 'dataType',\n  constraintName: 'constraint',\n  sourceFile: 'file',\n  sourceLine: 'line',\n  sourceFunction: 'routine'\n};\nNativeQuery.prototype.handleError = function (err) {\n  // copy pq error fields into the error object\n  var fields = this.native.pq.resultErrorFields();\n  if (fields) {\n    for (var key in fields) {\n      var normalizedFieldName = errorFieldMap[key] || key;\n      err[normalizedFieldName] = fields[key];\n    }\n  }\n  if (this.callback) {\n    this.callback(err);\n  } else {\n    this.emit('error', err);\n  }\n  this.state = 'error';\n};\nNativeQuery.prototype.then = function (onSuccess, onFailure) {\n  return this._getPromise().then(onSuccess, onFailure);\n};\nNativeQuery.prototype.catch = function (callback) {\n  return this._getPromise().catch(callback);\n};\nNativeQuery.prototype._getPromise = function () {\n  if (this._promise) return this._promise;\n  this._promise = new Promise(function (resolve, reject) {\n    this._once('end', resolve);\n    this._once('error', reject);\n  }.bind(this));\n  return this._promise;\n};\nNativeQuery.prototype.submit = function (client) {\n  this.state = 'running';\n  var self = this;\n  this.native = client.native;\n  client.native.arrayMode = this._arrayMode;\n  var after = function (err, rows, results) {\n    client.native.arrayMode = false;\n    setImmediate(function () {\n      self.emit('_done');\n    });\n\n    // handle possible query error\n    if (err) {\n      return self.handleError(err);\n    }\n\n    // emit row events for each row in the result\n    if (self._emitRowEvents) {\n      if (results.length > 1) {\n        rows.forEach((rowOfRows, i) => {\n          rowOfRows.forEach(row => {\n            self.emit('row', row, results[i]);\n          });\n        });\n      } else {\n        rows.forEach(function (row) {\n          self.emit('row', row, results);\n        });\n      }\n    }\n\n    // handle successful result\n    self.state = 'end';\n    self.emit('end', results);\n    if (self.callback) {\n      self.callback(null, results);\n    }\n  };\n  if (process.domain) {\n    after = process.domain.bind(after);\n  }\n\n  // named query\n  if (this.name) {\n    if (this.name.length > 63) {\n      /* eslint-disable no-console */\n      console.error('Warning! Postgres only supports 63 characters for query names.');\n      console.error('You supplied %s (%s)', this.name, this.name.length);\n      console.error('This can cause conflicts and silent errors executing queries');\n      /* eslint-enable no-console */\n    }\n    var values = (this.values || []).map(utils.prepareValue);\n\n    // check if the client has already executed this named query\n    // if so...just execute it again - skip the planning phase\n    if (client.namedQueries[this.name]) {\n      if (this.text && client.namedQueries[this.name] !== this.text) {\n        const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);\n        return after(err);\n      }\n      return client.native.execute(this.name, values, after);\n    }\n    // plan the named query the first time, then execute it\n    return client.native.prepare(this.name, this.text, values.length, function (err) {\n      if (err) return after(err);\n      client.namedQueries[self.name] = self.text;\n      return self.native.execute(self.name, values, after);\n    });\n  } else if (this.values) {\n    if (!Array.isArray(this.values)) {\n      const err = new Error('Query values must be an array');\n      return after(err);\n    }\n    var vals = this.values.map(utils.prepareValue);\n    client.native.query(this.text, vals, after);\n  } else {\n    client.native.query(this.text, after);\n  }\n};","map":{"version":3,"names":["EventEmitter","require","util","utils","NativeQuery","module","exports","config","values","callback","call","normalizeQueryConfig","text","name","state","_arrayMode","rowMode","_emitRowEvents","on","event","bind","inherits","errorFieldMap","sqlState","statementPosition","messagePrimary","context","schemaName","tableName","columnName","dataTypeName","constraintName","sourceFile","sourceLine","sourceFunction","prototype","handleError","err","fields","native","pq","resultErrorFields","key","normalizedFieldName","emit","then","onSuccess","onFailure","_getPromise","catch","_promise","Promise","resolve","reject","_once","submit","client","self","arrayMode","after","rows","results","setImmediate","length","forEach","rowOfRows","i","row","process","domain","console","error","map","prepareValue","namedQueries","Error","execute","prepare","Array","isArray","vals","query"],"sources":["/Users/cn/Documents/School/SYSC 4907 A/GitHub/personalportfolio/node_modules/pg/lib/native/query.js"],"sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('../utils')\n\nvar NativeQuery = (module.exports = function (config, values, callback) {\n  EventEmitter.call(this)\n  config = utils.normalizeQueryConfig(config, values, callback)\n  this.text = config.text\n  this.values = config.values\n  this.name = config.name\n  this.callback = config.callback\n  this.state = 'new'\n  this._arrayMode = config.rowMode === 'array'\n\n  // if the 'row' event is listened for\n  // then emit them as they come in\n  // without setting singleRowMode to true\n  // this has almost no meaning because libpq\n  // reads all rows into memory befor returning any\n  this._emitRowEvents = false\n  this.on(\n    'newListener',\n    function (event) {\n      if (event === 'row') this._emitRowEvents = true\n    }.bind(this)\n  )\n})\n\nutil.inherits(NativeQuery, EventEmitter)\n\nvar errorFieldMap = {\n  /* eslint-disable quote-props */\n  sqlState: 'code',\n  statementPosition: 'position',\n  messagePrimary: 'message',\n  context: 'where',\n  schemaName: 'schema',\n  tableName: 'table',\n  columnName: 'column',\n  dataTypeName: 'dataType',\n  constraintName: 'constraint',\n  sourceFile: 'file',\n  sourceLine: 'line',\n  sourceFunction: 'routine',\n}\n\nNativeQuery.prototype.handleError = function (err) {\n  // copy pq error fields into the error object\n  var fields = this.native.pq.resultErrorFields()\n  if (fields) {\n    for (var key in fields) {\n      var normalizedFieldName = errorFieldMap[key] || key\n      err[normalizedFieldName] = fields[key]\n    }\n  }\n  if (this.callback) {\n    this.callback(err)\n  } else {\n    this.emit('error', err)\n  }\n  this.state = 'error'\n}\n\nNativeQuery.prototype.then = function (onSuccess, onFailure) {\n  return this._getPromise().then(onSuccess, onFailure)\n}\n\nNativeQuery.prototype.catch = function (callback) {\n  return this._getPromise().catch(callback)\n}\n\nNativeQuery.prototype._getPromise = function () {\n  if (this._promise) return this._promise\n  this._promise = new Promise(\n    function (resolve, reject) {\n      this._once('end', resolve)\n      this._once('error', reject)\n    }.bind(this)\n  )\n  return this._promise\n}\n\nNativeQuery.prototype.submit = function (client) {\n  this.state = 'running'\n  var self = this\n  this.native = client.native\n  client.native.arrayMode = this._arrayMode\n\n  var after = function (err, rows, results) {\n    client.native.arrayMode = false\n    setImmediate(function () {\n      self.emit('_done')\n    })\n\n    // handle possible query error\n    if (err) {\n      return self.handleError(err)\n    }\n\n    // emit row events for each row in the result\n    if (self._emitRowEvents) {\n      if (results.length > 1) {\n        rows.forEach((rowOfRows, i) => {\n          rowOfRows.forEach((row) => {\n            self.emit('row', row, results[i])\n          })\n        })\n      } else {\n        rows.forEach(function (row) {\n          self.emit('row', row, results)\n        })\n      }\n    }\n\n    // handle successful result\n    self.state = 'end'\n    self.emit('end', results)\n    if (self.callback) {\n      self.callback(null, results)\n    }\n  }\n\n  if (process.domain) {\n    after = process.domain.bind(after)\n  }\n\n  // named query\n  if (this.name) {\n    if (this.name.length > 63) {\n      /* eslint-disable no-console */\n      console.error('Warning! Postgres only supports 63 characters for query names.')\n      console.error('You supplied %s (%s)', this.name, this.name.length)\n      console.error('This can cause conflicts and silent errors executing queries')\n      /* eslint-enable no-console */\n    }\n    var values = (this.values || []).map(utils.prepareValue)\n\n    // check if the client has already executed this named query\n    // if so...just execute it again - skip the planning phase\n    if (client.namedQueries[this.name]) {\n      if (this.text && client.namedQueries[this.name] !== this.text) {\n        const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n        return after(err)\n      }\n      return client.native.execute(this.name, values, after)\n    }\n    // plan the named query the first time, then execute it\n    return client.native.prepare(this.name, this.text, values.length, function (err) {\n      if (err) return after(err)\n      client.namedQueries[self.name] = self.text\n      return self.native.execute(self.name, values, after)\n    })\n  } else if (this.values) {\n    if (!Array.isArray(this.values)) {\n      const err = new Error('Query values must be an array')\n      return after(err)\n    }\n    var vals = this.values.map(utils.prepareValue)\n    client.native.query(this.text, vals, after)\n  } else {\n    client.native.query(this.text, after)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}