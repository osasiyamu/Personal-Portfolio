{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst NOOP = function () {};\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client;\n    this.idleListener = idleListener;\n    this.timeoutId = timeoutId;\n  }\n}\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback;\n  }\n}\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n  let rej;\n  let res;\n  const cb = function (err, client) {\n    err ? rej(err) : res(client);\n  };\n  const result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  }).catch(err => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err);\n    throw err;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n    pool._remove(client);\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client);\n  };\n}\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super();\n    this.options = Object.assign({}, options);\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      });\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false\n      });\n    }\n    this.options.max = this.options.max || this.options.poolSize || 10;\n    this.options.maxUses = this.options.maxUses || Infinity;\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;\n    this.log = this.options.log || function () {};\n    this.Client = this.options.Client || Client || require('pg').Client;\n    this.Promise = this.options.Promise || global.Promise;\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000;\n    }\n    this._clients = [];\n    this._idle = [];\n    this._expired = new WeakSet();\n    this._pendingQueue = [];\n    this._endCallback = undefined;\n    this.ending = false;\n    this.ended = false;\n  }\n  _isFull() {\n    return this._clients.length >= this.options.max;\n  }\n  _pulseQueue() {\n    this.log('pulse queue');\n    if (this.ended) {\n      this.log('pulse queue ended');\n      return;\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending');\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client);\n        });\n      }\n      if (!this._clients.length) {\n        this.ended = true;\n        this._endCallback();\n      }\n      return;\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests');\n      return;\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return;\n    }\n    const pendingItem = this._pendingQueue.shift();\n    if (this._idle.length) {\n      const idleItem = this._idle.pop();\n      clearTimeout(idleItem.timeoutId);\n      const client = idleItem.client;\n      client.ref && client.ref();\n      const idleListener = idleItem.idleListener;\n      return this._acquireClient(client, pendingItem, idleListener, false);\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem);\n    }\n    throw new Error('unexpected condition');\n  }\n  _remove(client) {\n    const removed = removeWhere(this._idle, item => item.client === client);\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId);\n    }\n    this._clients = this._clients.filter(c => c !== client);\n    client.end();\n    this.emit('remove', client);\n  }\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n    const response = promisify(this.Promise, cb);\n    const result = response.result;\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue());\n      }\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback));\n        return result;\n      }\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid);\n        response.callback(err, res, done);\n      };\n      const pendingItem = new PendingItem(queueCallback);\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, i => i.callback === queueCallback);\n        pendingItem.timedOut = true;\n        response.callback(new Error('timeout exceeded when trying to connect'));\n      }, this.options.connectionTimeoutMillis);\n      this._pendingQueue.push(pendingItem);\n      return result;\n    }\n    this.newClient(new PendingItem(response.callback));\n    return result;\n  }\n  newClient(pendingItem) {\n    const client = new this.Client(this.options);\n    this._clients.push(client);\n    const idleListener = makeIdleListener(this, client);\n    this.log('checking client timeout');\n\n    // connection timeout logic\n    let tid;\n    let timeoutHit = false;\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout');\n        timeoutHit = true;\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end();\n      }, this.options.connectionTimeoutMillis);\n    }\n    this.log('connecting new client');\n    client.connect(err => {\n      if (tid) {\n        clearTimeout(tid);\n      }\n      client.on('error', idleListener);\n      if (err) {\n        this.log('client failed to connect', err);\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter(c => c !== client);\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout';\n        }\n\n        // this client won’t be released, so move on immediately\n        this._pulseQueue();\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP);\n        }\n      } else {\n        this.log('new client connected');\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime');\n            this._expired.add(client);\n            const idleIndex = this._idle.findIndex(idleItem => idleItem.client === client);\n            if (idleIndex !== -1) {\n              this._acquireClient(client, new PendingItem((err, client, clientRelease) => clientRelease()), idleListener, false);\n            }\n          }, this.options.maxLifetimeSeconds * 1000);\n          maxLifetimeTimeout.unref();\n          client.once('end', () => clearTimeout(maxLifetimeTimeout));\n        }\n        return this._acquireClient(client, pendingItem, idleListener, true);\n      }\n    });\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client);\n    }\n    this.emit('acquire', client);\n    client.release = this._releaseOnce(client, idleListener);\n    client.removeListener('error', idleListener);\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, err => {\n          if (err) {\n            client.release(err);\n            return pendingItem.callback(err, undefined, NOOP);\n          }\n          pendingItem.callback(undefined, client, client.release);\n        });\n      } else {\n        pendingItem.callback(undefined, client, client.release);\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release);\n      } else {\n        client.release();\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false;\n    return err => {\n      if (released) {\n        throwOnDoubleRelease();\n      }\n      released = true;\n      this._release(client, idleListener, err);\n    };\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener);\n    client._poolUseCount = (client._poolUseCount || 0) + 1;\n    this.emit('release', err, client);\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client');\n      }\n      this._remove(client);\n      this._pulseQueue();\n      return;\n    }\n    const isExpired = this._expired.has(client);\n    if (isExpired) {\n      this.log('remove expired client');\n      this._expired.delete(client);\n      this._remove(client);\n      this._pulseQueue();\n      return;\n    }\n\n    // idle timeout\n    let tid;\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client');\n        this._remove(client);\n      }, this.options.idleTimeoutMillis);\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref();\n      }\n    }\n    if (this.options.allowExitOnIdle) {\n      client.unref();\n    }\n    this._idle.push(new IdleItem(client, idleListener, tid));\n    this._pulseQueue();\n  }\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text);\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n      });\n      return response.result;\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values;\n      values = undefined;\n    }\n    const response = promisify(this.Promise, cb);\n    cb = response.callback;\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err);\n      }\n      let clientReleased = false;\n      const onError = err => {\n        if (clientReleased) {\n          return;\n        }\n        clientReleased = true;\n        client.release(err);\n        cb(err);\n      };\n      client.once('error', onError);\n      this.log('dispatching query');\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched');\n          client.removeListener('error', onError);\n          if (clientReleased) {\n            return;\n          }\n          clientReleased = true;\n          client.release(err);\n          if (err) {\n            return cb(err);\n          }\n          return cb(undefined, res);\n        });\n      } catch (err) {\n        client.release(err);\n        return cb(err);\n      }\n    });\n    return response.result;\n  }\n  end(cb) {\n    this.log('ending');\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n    this.ending = true;\n    const promised = promisify(this.Promise, cb);\n    this._endCallback = promised.callback;\n    this._pulseQueue();\n    return promised.result;\n  }\n  get waitingCount() {\n    return this._pendingQueue.length;\n  }\n  get idleCount() {\n    return this._idle.length;\n  }\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);\n  }\n  get totalCount() {\n    return this._clients.length;\n  }\n}\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","NOOP","removeWhere","list","predicate","i","findIndex","undefined","splice","IdleItem","constructor","client","idleListener","timeoutId","PendingItem","callback","throwOnDoubleRelease","Error","promisify","Promise","result","rej","res","cb","err","resolve","reject","catch","captureStackTrace","makeIdleListener","pool","removeListener","on","log","_remove","emit","Pool","options","Client","Object","assign","defineProperty","configurable","enumerable","writable","value","password","ssl","key","max","poolSize","maxUses","Infinity","allowExitOnIdle","maxLifetimeSeconds","global","idleTimeoutMillis","_clients","_idle","_expired","WeakSet","_pendingQueue","_endCallback","ending","ended","_isFull","length","_pulseQueue","slice","map","item","pendingItem","shift","idleItem","pop","clearTimeout","ref","_acquireClient","newClient","removed","filter","c","end","connect","response","process","nextTick","connectionTimeoutMillis","push","queueCallback","done","tid","setTimeout","timedOut","timeoutHit","connection","stream","destroy","message","maxLifetimeTimeout","add","idleIndex","clientRelease","unref","once","isNew","release","_releaseOnce","verify","released","_release","_poolUseCount","_queryable","_ending","isExpired","has","delete","query","text","values","setImmediate","clientReleased","onError","promised","waitingCount","idleCount","expiredCount","reduce","acc","totalCount","module","exports"],"sources":["/Users/cn/Documents/School/SYSC 4907 A/GitHub/personalportfolio/node_modules/pg-pool/index.js"],"sourcesContent":["'use strict'\nconst EventEmitter = require('events').EventEmitter\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch(err => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err);\n    throw err;\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || require('pg').Client\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client won’t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}