{"ast":null,"code":"'use strict';\n\nvar net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nconst {\n  parse,\n  serialize\n} = require('pg-protocol');\nconst {\n  getStream,\n  getSecureStream\n} = require('./stream');\nconst flushBuffer = serialize.flush();\nconst syncBuffer = serialize.sync();\nconst endBuffer = serialize.end();\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.stream = config.stream || getStream(config.ssl);\n    if (typeof this.stream === 'function') {\n      this.stream = this.stream(config);\n    }\n    this._keepAlive = config.keepAlive;\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    this.lastBuffer = false;\n    this.parsedStatements = {};\n    this.ssl = config.ssl || false;\n    this._ending = false;\n    this._emitMessage = false;\n    var self = this;\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n  }\n  connect(port, host) {\n    var self = this;\n    this._connecting = true;\n    this.stream.setNoDelay(true);\n    this.stream.connect(port, host);\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n      }\n      self.emit('connect');\n    });\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return;\n      }\n      self.emit('error', error);\n    };\n    this.stream.on('error', reportStreamError);\n    this.stream.on('close', function () {\n      self.emit('end');\n    });\n    if (!this.ssl) {\n      return this.attachListeners(this.stream);\n    }\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8');\n      switch (responseCode) {\n        case 'S':\n          // Server supports SSL connections, continue with a secure connection\n          break;\n        case 'N':\n          // Server does not support SSL connections\n          self.stream.end();\n          return self.emit('error', new Error('The server does not support SSL connections'));\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end();\n          return self.emit('error', new Error('There was an error establishing an SSL connection'));\n      }\n      const options = {\n        socket: self.stream\n      };\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl);\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key;\n        }\n      }\n      var net = require('net');\n      if (net.isIP && net.isIP(host) === 0) {\n        options.servername = host;\n      }\n      try {\n        self.stream = getSecureStream(options);\n      } catch (err) {\n        return self.emit('error', err);\n      }\n      self.attachListeners(self.stream);\n      self.stream.on('error', reportStreamError);\n      self.emit('sslconnect');\n    });\n  }\n  attachListeners(stream) {\n    parse(stream, msg => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n      if (this._emitMessage) {\n        this.emit('message', msg);\n      }\n      this.emit(eventName, msg);\n    });\n  }\n  requestSsl() {\n    this.stream.write(serialize.requestSsl());\n  }\n  startup(config) {\n    this.stream.write(serialize.startup(config));\n  }\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey));\n  }\n  password(password) {\n    this._send(serialize.password(password));\n  }\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n  }\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n  }\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false;\n    }\n    return this.stream.write(buffer);\n  }\n  query(text) {\n    this._send(serialize.query(text));\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query));\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config));\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config));\n  }\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer);\n    }\n  }\n  sync() {\n    this._ending = true;\n    this._send(syncBuffer);\n  }\n  ref() {\n    this.stream.ref();\n  }\n  unref() {\n    this.stream.unref();\n  }\n  end() {\n    // 0x58 = 'X'\n    this._ending = true;\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end();\n      return;\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end();\n    });\n  }\n  close(msg) {\n    this._send(serialize.close(msg));\n  }\n  describe(msg) {\n    this._send(serialize.describe(msg));\n  }\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk));\n  }\n  endCopyFrom() {\n    this._send(serialize.copyDone());\n  }\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg));\n  }\n}\nmodule.exports = Connection;","map":{"version":3,"names":["net","require","EventEmitter","parse","serialize","getStream","getSecureStream","flushBuffer","flush","syncBuffer","sync","endBuffer","end","Connection","constructor","config","stream","ssl","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","_ending","_emitMessage","self","on","eventName","connect","port","host","_connecting","setNoDelay","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","Error","options","socket","Object","assign","key","isIP","servername","err","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","ref","unref","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"sources":["/Users/cn/Documents/School/SYSC 4907 A/GitHub/personalportfolio/node_modules/pg/lib/connection.js"],"sourcesContent":["'use strict'\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\n\nconst { parse, serialize } = require('pg-protocol')\nconst { getStream, getSecureStream } = require('./stream')\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n\n    this.stream = config.stream || getStream(config.ssl)\n    if (typeof this.stream === 'function') {\n      this.stream = this.stream(config)\n    }\n\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    var self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    var self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      var net = require('net')\n      if (net.isIP && net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = getSecureStream(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    parse(stream, (msg) => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(syncBuffer)\n  }\n\n  ref() {\n    this.stream.ref()\n  }\n\n  unref() {\n    this.stream.unref()\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}