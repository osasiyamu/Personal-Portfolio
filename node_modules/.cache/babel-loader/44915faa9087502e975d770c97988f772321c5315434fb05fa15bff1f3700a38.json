{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\nconst Result = require('./result');\nconst utils = require('./utils');\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super();\n    config = utils.normalizeQueryConfig(config, values, callback);\n    this.text = config.text;\n    this.values = config.values;\n    this.rows = config.rows;\n    this.types = config.types;\n    this.name = config.name;\n    this.binary = config.binary;\n    // use unique portal name each time\n    this.portal = config.portal || '';\n    this.callback = config.callback;\n    this._rowMode = config.rowMode;\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback);\n    }\n    this._result = new Result(this._rowMode, this.types);\n\n    // potential for multiple results\n    this._results = this._result;\n    this.isPreparedStatement = false;\n    this._canceledDueToError = false;\n    this._promise = null;\n  }\n  requiresPreparation() {\n    // named queries must always be prepared\n    if (this.name) {\n      return true;\n    }\n    // always prepare if there are max number of rows expected per\n    // portal execution\n    if (this.rows) {\n      return true;\n    }\n    // don't prepare empty text queries\n    if (!this.text) {\n      return false;\n    }\n    // prepare if there are values\n    if (!this.values) {\n      return false;\n    }\n    return this.values.length > 0;\n  }\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result];\n      }\n      this._result = new Result(this._rowMode, this.types);\n      this._results.push(this._result);\n    }\n  }\n\n  // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n  handleRowDescription(msg) {\n    this._checkForMultirow();\n    this._result.addFields(msg.fields);\n    this._accumulateRows = this.callback || !this.listeners('row').length;\n  }\n  handleDataRow(msg) {\n    let row;\n    if (this._canceledDueToError) {\n      return;\n    }\n    try {\n      row = this._result.parseRow(msg.fields);\n    } catch (err) {\n      this._canceledDueToError = err;\n      return;\n    }\n    this.emit('row', row, this._result);\n    if (this._accumulateRows) {\n      this._result.addRow(row);\n    }\n  }\n  handleCommandComplete(msg, connection) {\n    this._checkForMultirow();\n    this._result.addCommandComplete(msg);\n    // need to sync after each command complete of a prepared statement\n    // if we were using a row count which results in multiple calls to _getRows\n    if (this.rows) {\n      connection.sync();\n    }\n  }\n\n  // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // since we pipeline sync immediately after execute we don't need to do anything here\n  // unless we have rows specified, in which case we did not pipeline the intial sync call\n  handleEmptyQuery(connection) {\n    if (this.rows) {\n      connection.sync();\n    }\n  }\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError;\n      this._canceledDueToError = false;\n    }\n    // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n    if (this.callback) {\n      return this.callback(err);\n    }\n    this.emit('error', err);\n  }\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con);\n    }\n    if (this.callback) {\n      try {\n        this.callback(null, this._results);\n      } catch (err) {\n        process.nextTick(() => {\n          throw err;\n        });\n      }\n    }\n    this.emit('end', this._results);\n  }\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n    }\n    const previous = connection.parsedStatements[this.name];\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);\n    }\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array');\n    }\n    if (this.requiresPreparation()) {\n      this.prepare(connection);\n    } else {\n      connection.query(this.text);\n    }\n    return null;\n  }\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name];\n  }\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows);\n  }\n  _getRows(connection, rows) {\n    connection.execute({\n      portal: this.portal,\n      rows: rows\n    });\n    // if we're not reading pages of rows send the sync command\n    // to indicate the pipeline is finished\n    if (!rows) {\n      connection.sync();\n    } else {\n      // otherwise flush the call out to read more rows\n      connection.flush();\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  prepare(connection) {\n    // prepared statements need sync to be called after each command\n    // complete or when an error is encountered\n    this.isPreparedStatement = true;\n\n    // TODO refactor this poor encapsulation\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse({\n        text: this.text,\n        name: this.name,\n        types: this.types\n      });\n    }\n\n    // because we're mapping user supplied values to\n    // postgres wire protocol compatible values it could\n    // throw an exception, so try/catch this section\n    try {\n      connection.bind({\n        portal: this.portal,\n        statement: this.name,\n        values: this.values,\n        binary: this.binary,\n        valueMapper: utils.prepareValue\n      });\n    } catch (err) {\n      this.handleError(err, connection);\n      return;\n    }\n    connection.describe({\n      type: 'P',\n      name: this.portal || ''\n    });\n    this._getRows(connection, this.rows);\n  }\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined');\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  handleCopyData(msg, connection) {\n    // noop\n  }\n}\nmodule.exports = Query;","map":{"version":3,"names":["EventEmitter","require","Result","utils","Query","constructor","config","values","callback","normalizeQueryConfig","text","rows","types","name","binary","portal","_rowMode","rowMode","process","domain","bind","_result","_results","isPreparedStatement","_canceledDueToError","_promise","requiresPreparation","length","_checkForMultirow","command","Array","isArray","push","handleRowDescription","msg","addFields","fields","_accumulateRows","listeners","handleDataRow","row","parseRow","err","emit","addRow","handleCommandComplete","connection","addCommandComplete","sync","handleEmptyQuery","handleError","handleReadyForQuery","con","nextTick","submit","Error","previous","parsedStatements","prepare","query","hasBeenParsed","handlePortalSuspended","_getRows","execute","flush","parse","statement","valueMapper","prepareValue","describe","type","handleCopyInResponse","sendCopyFail","handleCopyData","module","exports"],"sources":["/Users/cn/Documents/School/SYSC 4907 A/GitHub/personalportfolio/node_modules/pg/lib/query.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\n\nconst Result = require('./result')\nconst utils = require('./utils')\n\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super()\n\n    config = utils.normalizeQueryConfig(config, values, callback)\n\n    this.text = config.text\n    this.values = config.values\n    this.rows = config.rows\n    this.types = config.types\n    this.name = config.name\n    this.binary = config.binary\n    // use unique portal name each time\n    this.portal = config.portal || ''\n    this.callback = config.callback\n    this._rowMode = config.rowMode\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback)\n    }\n    this._result = new Result(this._rowMode, this.types)\n\n    // potential for multiple results\n    this._results = this._result\n    this.isPreparedStatement = false\n    this._canceledDueToError = false\n    this._promise = null\n  }\n\n  requiresPreparation() {\n    // named queries must always be prepared\n    if (this.name) {\n      return true\n    }\n    // always prepare if there are max number of rows expected per\n    // portal execution\n    if (this.rows) {\n      return true\n    }\n    // don't prepare empty text queries\n    if (!this.text) {\n      return false\n    }\n    // prepare if there are values\n    if (!this.values) {\n      return false\n    }\n    return this.values.length > 0\n  }\n\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result]\n      }\n      this._result = new Result(this._rowMode, this.types)\n      this._results.push(this._result)\n    }\n  }\n\n  // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n  handleRowDescription(msg) {\n    this._checkForMultirow()\n    this._result.addFields(msg.fields)\n    this._accumulateRows = this.callback || !this.listeners('row').length\n  }\n\n  handleDataRow(msg) {\n    let row\n\n    if (this._canceledDueToError) {\n      return\n    }\n\n    try {\n      row = this._result.parseRow(msg.fields)\n    } catch (err) {\n      this._canceledDueToError = err\n      return\n    }\n\n    this.emit('row', row, this._result)\n    if (this._accumulateRows) {\n      this._result.addRow(row)\n    }\n  }\n\n  handleCommandComplete(msg, connection) {\n    this._checkForMultirow()\n    this._result.addCommandComplete(msg)\n    // need to sync after each command complete of a prepared statement\n    // if we were using a row count which results in multiple calls to _getRows\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // since we pipeline sync immediately after execute we don't need to do anything here\n  // unless we have rows specified, in which case we did not pipeline the intial sync call\n  handleEmptyQuery(connection) {\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError\n      this._canceledDueToError = false\n    }\n    // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n    if (this.callback) {\n      return this.callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con)\n    }\n    if (this.callback) {\n      try {\n        this.callback(null, this._results)\n      }\n      catch(err) {\n        process.nextTick(() => {\n          throw err\n        })\n      }\n    }\n    this.emit('end', this._results)\n  }\n\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    }\n    const previous = connection.parsedStatements[this.name]\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n    }\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array')\n    }\n    if (this.requiresPreparation()) {\n      this.prepare(connection)\n    } else {\n      connection.query(this.text)\n    }\n    return null\n  }\n\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name]\n  }\n\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows)\n  }\n\n  _getRows(connection, rows) {\n    connection.execute({\n      portal: this.portal,\n      rows: rows,\n    })\n    // if we're not reading pages of rows send the sync command\n    // to indicate the pipeline is finished\n    if (!rows) {\n      connection.sync()\n    } else {\n      // otherwise flush the call out to read more rows\n      connection.flush()\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  prepare(connection) {\n    // prepared statements need sync to be called after each command\n    // complete or when an error is encountered\n    this.isPreparedStatement = true\n\n    // TODO refactor this poor encapsulation\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse({\n        text: this.text,\n        name: this.name,\n        types: this.types,\n      })\n    }\n\n    // because we're mapping user supplied values to\n    // postgres wire protocol compatible values it could\n    // throw an exception, so try/catch this section\n    try {\n      connection.bind({\n        portal: this.portal,\n        statement: this.name,\n        values: this.values,\n        binary: this.binary,\n        valueMapper: utils.prepareValue,\n      })\n    } catch (err) {\n      this.handleError(err, connection)\n      return\n    }\n\n    connection.describe({\n      type: 'P',\n      name: this.portal || '',\n    })\n\n    this._getRows(connection, this.rows)\n  }\n\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined')\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  handleCopyData(msg, connection) {\n    // noop\n  }\n}\n\nmodule.exports = Query\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}